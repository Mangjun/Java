# OOP

## 객체지향 프로그래밍이란?
객체지향의 개념은 **실제 세계는 객체로 이루어져 있으며, 발생하는 모든 사건들은 객체간의 상호작용이다.**이다.   
객체지향 프로그래밍은 실제 객체의 속성과 기능을 분석한 다음, 데이터와 함수로 정의함으로써 가상 세계를 구현하는 기법이다.   

## 객체지향언어 특징
1. 코드의 재사용성이 높다.
2. 코드의 관리가 용이하다.
3. 신뢰성이 높은 프로그래밍을 가능하게 한다.

## 클래스와 객체
클래스는 3가지로 정의할 수 있는데 첫 번째로 **객체를 만들기 위한 설계도**이다.   
여기서 객체는 실제 존재하는 것으로 Java에서는 **new 연산자**를 통해 객체를 생성한다.   
클래스를 통해 만들어진 객체를 인스턴스라고 한다.   
객체는 속성과 기능으로 이루어져 있으며 클래스에서 속성은 변수로 기능은 메서드로 구현한다.   

두 번째로 **데이터 + 함수**로 이루어진 자료형이다. 데이터는 속성을 함수는 기능을 정의한다.   
클래스의 대표적인 예로 문자열이 있다. C에서는 문자의 배열로 다루지만 왜 Java에서는 클래스로 정의했을까?   
그 이유는 문자열과 문자열을 다루는데 필요한 함수들을 함께 묶기 위해서이다. 이렇게 하면 작업이 간단하고 명료해진다.   

세 번째로 **사용자 정의 타입**이다. 예를 들어 아래와 같이 시간을 표현할 때 시, 분, 초를 하나로 묶어 사용할 수 있다.   
```
class Time {   
    int hour; // 시   
    int minute; // 분   
    int second; // 초   
}
```

## 클래스의 구성
클래스는 필드와 생성자, 메서드로 구성되어있다.
```
class MyClass {   
    // field: 클래스에 포함된 변수   
    String name;   
   
    // Constructor: 객체의 생성과 동시에 인스턴스변수를 원하는 값으로 초기화할 수 있는 특수한 메서드   
    MyClass() {}   
   
   // Method: 어떠한 특정 작업을 수행하기위한 명령문의 집합   
   void print() { /* 출력 */ }   
}   
```

## JVM의 메모리 구조
JVM의 메모리에는 3가지 영역인 메서드 영역, 호출 스택, 힙 영역이 있다.   
메서드 영역은 클래스 정보와 클래스변수를 저장하는 영역이다.   
호출 스택은 메서드의 작업 공간으로 호출되면 메모리 공간을 할당받고 종료되면 반환한다.   
메서드는 1개만 실행하고 나머지는 대기중인데 호출 스택 제일 위에 있는 메서드가 현재 실행중인 메서드이며, 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.   
힙 영역은 인스턴스가 생성되는 공간이다.   
new 연산자에 의해 생성되는 배열과 객체는 모두 여기에 생성이 된다.   

## 변수의 종류
변수는 **선언 위치**에 따라 결정된다.   

| 변수의 종류 | 선언 위치 | 생성 시기 |
|---|---|---|
| 클래스변수 | 클래스 영역 | 클래스가 메모리에 올라갈 때 |
| 인스턴스변수 | 클래스 영역 | 인스턴스 생성 시 |
| 지역변수 | 메서드 영역 | 변수 선언문 수행 시 |

클래스변수와 인스턴스변수를 멤버변수라고 하고 멤버변수를 제외한 나머지 변수들은 모두 지역변수이다.   
멤버변수 중에서 **static**이 붙은 것은 클래스변수, 붙지 않은 것은 인스턴스변수이다.   
여기서 주의할 점은 **클래스 영역에는 선언문만 가능하다.**   

인스턴스변수는 먼저 인스턴스를 생성해야 사용할 수 있으며, 인스턴스마다 서로 다른 값을 가질 수 있다.   
클래스변수는 모든 인스턴스가 공유한다.   
그러므로 **공통적인 값을 유지해야하는 속성인 경우 클래스변수로, 서로 다른 값을 가져야한다면 인스턴스변수로 선언한다.**   
인스턴스변수는 참조변수.인스턴스변수로 사용하고, 클래스변수는 클래스이름.클래스변수로 사용하자.   

## 변수의 초기화
변수의 초기화는 변수를 선언하고 처음으로 값을 저장하는 것을 의미한다.   
변수의 종류에 따라 초기화 방법이 다른데, 멤버변수는 초기화를 생략 가능하고, 지역변수는 반드시 직접 초기화를 해줘야 한다.   
멤버변수 초기화를 생략하면 논리형은 false, 숫자형은 0, 문자형은 공백, 참조형은 null로 초기화된다.   

멤버변수 초기화의 종류로는 3가지가 있는데 자동 초기화, 간단 초기화(명시적 초기화), 복잡 초기화가 있다.   
첫 번째로 자동 초기화는 변수만 선언하면 된다. 위와 같이 논리형은 false, 숫자형은 0, 문자형은 공백, 참조형은 null로 초기화된다.   
두 번째로 간단 초기화는 대입 연산자(=)를 이용해 초기화한다.   
세 번째로 복잡 초기화는 클래스변수는 클래스 초기화블럭을 사용하고, 인스턴스변수는 생성자와 인스턴스 초기화블럭을 사용한다.   

멤버변수 초기화 시점으로는 클래스변수는 클래스가 처음 로딩될 때 단 한번만 하고 인스턴스변수는 인스턴스가 생성될 때마다 초기화된다.   
클래스변수가 초기화된 후 인스턴스변수가 초기화되고 자동 초기화, 간단 초기화, 복잡 초기화순으로 초기화된다.   

1. 클래스변수 기본값
2. 클래스변수 명시적 초기화
3. 클래스변수 클래스 초기화 블럭
4. 인스턴스변수 기본값
5. 인스턴스변수 명시적 초기화
6. 인스턴스변수 인스턴스 초기화 블럭
7. 인스턴스변수 생성자

## 메서드
클래스영역에만 정의가능한 함수이다.   
반복적으로 수행되는 여러 문장들을 메서드로 작성하고 **하나의 메서드는 하나의 기능만 수행하도록 작성한다.**   

메서드를 사용하는 이유는 세 가지다.   

1. 높은 재사용성
2. 코드 중복 제거
3. 프로그램의 구조화

main 메서드는 프로그램의 전체 흐름이 한눈에 들어올 정도로 단순하게 구조화하는 것이 좋다.   
**메서드에는 반드시 return문이 있어야 한다.**   

메서드는 참조변수.메서드이름();으로 호출한다.   
메서드를 호출할 때 괄호()안에 지정해준 값들을 인자 또는 인수라고 한다.   
인자의 타입은 매개변수의 타입과 일치하거나 자동 형변환이 가능한 것이어야 한다.   

## 매개변수의 종류
매개변수는 메서드를 정의할 때 메서드의 괄호()안에 지정해준 값이다.   

2가지의 종류가 있는데 기본형 매개변수와 참조형 매개변수가 있다.   
기본형 매개변수는 오로지 변수의 값을 읽기만 할 수 있다.   
참조형 매개변수는 변수의 값을 읽고 변경 가능하다.   
왜 그럴까? 이유는 Java는 메서드를 호출할 때 인자를 메서드의 매개변수에 복사해서 넘겨주기 때문이다.   

따라서 값을 변경해야한다면 참조형 매개변수를 사용하자.   

## 메서드의 종류
인스턴스변수의 사용여부에 따라 나뉜다. 인스턴스변수를 사용하면 인스턴스메서드 그렇지 않다면 클래스메서드이다.   
변수와 같이 클래스메서드는 인스턴스메서드에 static 키워드를 붙인다.   

인스턴스메서드는 인스턴스 생성 후에 참조변수.메서드이름();으로 호출하고, 클래스메서드는 객체 생성없이 클래스이름.메서드이름();으로 호출한다.   

클래스 메서드 내에서는 인스턴스멤버를 사용할 수 없다.   
왜냐하면 인스턴스멤버는 인스턴스를 생성해야 사용할 수 있는데 클래스메서드를 호출할 때 인스턴스가 생성이 되었다고 보장을 할 수 없기때문이다.   

따라서 메서드내에서 인스턴스멤버를 사용하지 않는다면 클래스메서드를 고려하자.   

## 메서드 오버로딩
한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것을 의미한다.   
메서드의 이름을 절약할 수 있고 메서드의 이름을 외우기 쉽다는 장점이 있다.   

오버로딩은 다음과 같은 조건을 만족해야한다.   

1. 메서드 이름이 같아야 한다.
2. 매개변수의 개수 또는 타입이 달라야 한다.

가능하면 가변인자를 사용한 메서드는 오버로딩하지 않는 것이 좋다.   

## 생성자
인스턴스 초기화 메서드이다. 메서드라서 오버로딩이 가능하다.   

생성자의 조건은 다음과 같다.   

1. 생성자의 이름은 클래스의 이름과 같아야 한다.
2. 생성자는 리턴 값이 없다.

모든 클래스는 반드시 하나 이상의 생성자가 있어야 한다.   
클래스에 생성자가 하나라도 없으면 컴파일러가 기본 생성자를 추가해준다.   

생성자에서 다른 생성자를 호출 가능한데 두 조건을 만족시켜야 한다.   

1. 생성자의 이름으로 클래스이름 대신 this를 사용한다.
2. 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.

왜 반드시 첫 줄에서만 호출해야 될까? 다른 생성자를 호출하기 이전의 초기화 작업이 무의미해질 수 있기 때문이다.   

생성자 this()는 같은 클래스의 다른 생성자를 호출할 때 사용한다.   
참조변수 this는 인스턴스 자신을 가리키는 참조변수로 인스턴스변수와 지역변수가 이름이 같을 때 구별하기 위해서 사용한다.   
인스턴스 자신을 가리키는 참조변수이므로 클래스메서드에선 사용할 수 없다.   

생성자를 이용해서 인스턴스를 복사할 수도 있다.   
```
MyClass(MyClass c) {   
    this(c.name);
}   
   
MyClass(String name) {   
    this.name = name;   
}   
```